function sketch(p)
{
	//// SKETCH 'CONSTANTS'
	
	// Used to dampen the node's animation. 
	// 0.0 - 1.0, A value of 1 would instantly snap the node to the desired position.
	var dampen = 0.1; 
	
	// Position of focussed node
	var leftXPos = 10;
	var focusYPos = 10;
	var offscreenYPos = 600;
	
	
	
	//// SKETCH VARS
	
	// As above, but x will vary
	var focusXPos;
	
	// Font in three weights
	var fontBold, fontRegular, fontLight;
	
	// History queue of the currently focussed node
	var nodeFocus = new Array();
	
	// Selection list for navigation of event list and current properties
	var nodeFocusPropertySelection = new SelectedIndexArray();
	
	// Dictionary of the currently active nodes
	var storyArray = new SelectedIndexArray();
	var nodeDict = new Object();
	var oldNodeDict = new Object();
	
	
	
	//// SELECTED NODE CONTROL 
	// 	 Can be called from host
	
	// PUBLIC METHOD - Start things off with a story
	
	p.setCurrentStory = function(key)
	{
		this.currentStoryKey = key;
			
		if (key in window.downloadedObjects)
		{
			storyArray.reset();
			
			// eventList doesn't have a zero index, as the OLOntology starts at 1
			// we need to copy the elements in this array, rather than pass the object, because we're about to add the story as its zero value
			var eventList = window.downloadedObjects[key]["http://purl.org/ontology/stories/events"].filter(function() {return true});
			eventList.unshift(key);
						
			storyArray.nodeKeys = eventList;
			
			focusXPos = leftXPos;
			
			for (var i = 0; i < eventList.length; i++)
			{
				storyArray.array[i] = new CharNode(focusXPos, focusYPos, (i==0)?"S":String(i));
			}
			
			p.setFocussedNode(focusXPos, focusYPos, storyArray.nodeKeys[0])
			
			setStoryNodesSpacing();
		}
		else
		{
			subjectQuery(key);
		}
	}
	
	// PUBLIC METHOD - Set the currently focussed node, and set in chain the display of subnodes.

	p.setFocussedNode = function(x,y, key)
	{
		nodeFocus[0] = key;
	
		holdDict = nodeDict;
		oldNodeDict = new Object();
		nodeDict = new Object();		
		
		// Move nodes to the oldNodeDict, keeping the focussed node if we have it. GGRRRRRRR delete keyword silently fails.
		for (var forKey in holdDict)
		{
			if (forKey == key) 
			{
				nodeDict[forKey] = holdDict[forKey];
			}
			else
			{
				oldNodeDict[forKey] = holdDict[forKey];
			}
		}
		
		if (key in nodeDict)
		{
			// Move it to new on-screen position
			nodeDict[key].moveTo(x,y);
		}
		else
		{
			// Create it
			nodeDict[key] = new Node(x,offscreenYPos,key);
			nodeDict[key].moveTo(x,y);
		}
		
		for (var i in oldNodeDict)
		{
			oldNodeDict[i].moveTo(oldNodeDict[i].xPos, offscreenYPos);
		}
		
		// If we don't have object downloaded already, query the triplestore for all its statements.
		// subjectQuery assembles and sends off the query 
		// it callbacks objectReturn which on receipt of RDF assembles and massages into the kind of object we want.
		if (!(key in window.downloadedObjects))
		{
			subjectQuery(key);
		}
		else
		{
			// big rejig is to separate getting nodes vs laying them out. then no visual glitch as can pull subnodes out of existing nodeDict, as well as making code more elegant.
			createSubNodes(x,y);
		}
	}
	
	// SKETCH METHOD - Parse the focussed node for properties, and display them as sub-nodes
	
	createSubNodes = function(x,y)
	{
		createSubNode = function(objectKey)
		{
			// Add the object's key to the navigation selection
			nodeFocusPropertySelection.push(objectKey);
					
			// If we don't have it yet, ask the triplestore
			if (!(objectKey in window.downloadedObjects))
			{
				subjectQuery(objectKey);
			}
			
		 	// If its already on-screen, move it. If not, create the node.
			if (objectKey in nodeDict)
			{
				nodeDict[objectKey].moveTo(x,runningYPos);
				runningYPos += nodeDict[objectKey].height;
			}
			else
			{
				node = new Node(x,offscreenYPos,objectKey);
				node.moveTo(x, runningYPos);
				nodeDict[objectKey] = node;
				runningYPos += node.height;
			}
		}
		
		// Reset our list of the focussed node's properties used for navigation
		nodeFocusPropertySelection.reset();
		
		var runningYPos = y + nodeDict[nodeFocus[0]].height;
		// Loop through properties of focussed node
		for (var predicateKey in downloadedObjects[nodeFocus[0]])
		{
			// Ignore RDF-type, its aggregated into node
			if (predicateKey == "http://www.w3.org/1999/02/22-rdf-syntax-ns#type") {}
			// Ignore text array, its for display in the node
			else if (predicateKey == "text") {}
			// TODO. Ignoring Interpretations for now, also we want to filter them against the current story
			//else if (predicateKey == "http://purl.org/ontology/stories/contextualises") {}
			else
			{
				// We should have an array of all this predicate's subjects
				var subjectArray = downloadedObjects[nodeFocus[0]][predicateKey];
				subjectArray.forEach( function(element) { createSubNode(element) });
			}
		}
	}

	// SKETCH METHOD - Update spacing of story nodes. 
	
	//As nodes are loaded in asyncronously, this gets called a lot to rejig things
	setStoryNodesSpacing = function()
	{
			var runningXPos = leftXPos;

			for (var i = 0; i < storyArray.array.length; i++)
			{
				storyArray.array[i].moveTo(runningXPos, focusYPos);
				
				if (i == storyArray.selectedIndex())
				{
					focusXPos = runningXPos;
					if (storyArray.nodeKeys[i] in nodeDict) runningXPos += nodeDict[storyArray.nodeKeys[i]].width;
				}
				else
					runningXPos += storyArray.array[i].width;
			}
	}
	
	//  SKETCH METHOD - This is triggered when object is brought in from triplestore.
	
	// The node should already have been created, so this is the prompt to rejig display now the contents are known
	objectDownloadedCallback = function(key)
	{
		// Is the downloaded object a story?
		if (downloadedObjects[key]["http://www.w3.org/1999/02/22-rdf-syntax-ns#type"] == "http://purl.org/ontology/stories/Story")
		{
			p.setCurrentStory(key);
		}
		// Is the downloaded object the focussed node?
		else if (key == nodeFocus[0])
		{
			nodeDict[key].initFromDownloadedObjectsData();
			// Have another go at creating property nodes now we know what they are
			setStoryNodesSpacing();
			nodeDict[key].moveTo(focusXPos, focusYPos);
			createSubNodes(focusXPos, focusYPos);
		}
		// Is the downloaded object a current node?
		else if (key in nodeDict)
		{
			nodeDict[key].initFromDownloadedObjectsData();
			// We need to update the spacing, now the node has a proper height
			// conveniently, this function will do it for us (subNodes of foccused node, not this node)
			setStoryNodesSpacing();
			createSubNodes(focusXPos, focusYPos);
		}
	}


	
	//// PROCESSING SETUP METHOD
	
	p.setup = function()
	{
	    p.size(1366, 768);
	  
	  // FIXME: 
	  // Oct'11 - Using native fonts and no performance impact now looks doable. Work out how to load font into the canvas element, so pjs can then pick it up.
	  // This will just use safari's default. Helvetica, could be worse =] No idea about other browsers.
	    fontBold = p.createFont("", 0);
	    fontRegular = p.createFont("", 0);
	    fontLight = p.createFont("", 0);
		
		// Register for notification when object has been downloaded from triplestore
		window.objectDownloadedCallback = objectDownloadedCallback;
	}



		
	//// PROCESSING DRAW METHOD
	
	p.draw = function()
	{
	  p.background(0,0,0,0);
		
		storyArray.array.forEach( function (element) 
		{
			element.update();
			element.draw();	
		});
		
	  for (var key in nodeDict)
	  {
	  	nodeDict[key].update();
	  	nodeDict[key].draw(key == nodeFocusPropertySelection.selectedObject());
	  }

	  for (var key in oldNodeDict)
	  {
	  	oldNodeDict[key].update();
	  	oldNodeDict[key].draw();
	  }

	}
	



	//// PROCESSING INPUT EVENT HANDLERS
	
	p.keyPressed = function ()
	{
		// LEFT = We want to back to the previous story event if we haven't pulled up properties to back out of first
		//if (p.keyCode == p.LEFT) p.LEFT worked in processing.js 0.9.6 but not 0.9.7
		if (p.keyCode == 37 && nodeFocus.length == 1) 
		{
			storyArray.selectionDown();
			setStoryNodesSpacing();
			p.setFocussedNode(focusXPos, focusYPos, storyArray.nodeKeys[storyArray.selectedIndex()]);
			setStoryNodesSpacing();
		}
		
		// RIGHT = We want to go to the next story event if we haven't pulled up properties to back out of first
		//if (p.keyCode == p.RIGHT)
		if (p.keyCode == 39 && nodeFocus.length == 1)
		{
			storyArray.selectionUp();
			setStoryNodesSpacing();
			p.setFocussedNode(focusXPos, focusYPos, storyArray.nodeKeys[storyArray.selectedIndex()]);
			setStoryNodesSpacing();
		}
		
		// SPACE = Pull up currently selected property
		if (p.key == 32)
		{
			// Insert new object in focus key at beginning of history array
			nodeFocus.unshift(nodeFocusPropertySelection.selectedObject())
			p.setFocussedNode(focusXPos, focusYPos, nodeFocusPropertySelection.selectedObject());
			setStoryNodesSpacing();
		}
		
		// ESC = Go back to last selected property
		// if (p.key == p.ESC)
		if (p.key == 27)
		{
			if (nodeFocus.length > 1)
			{
				nodeFocus.shift();
				p.setFocussedNode(focusXPos, focusYPos, nodeFocus[0]);
				setStoryNodesSpacing();
			}
		}
		
		// UP = Select node above
		//if (p.keyCode == p.UP) 
		if (p.keyCode == 38) 
		{
			nodeFocusPropertySelection.selectionDown();
		}
		
		// DOWN = Select node below
		//if (p.keyCode == p.DOWN) 
		if (p.keyCode == 40) 
		{
			nodeFocusPropertySelection.selectionUp();
		}
	}

	


	//// SKETCH CLASSES
	
	// This is an object that just displays a line of text, intended as a single character
	
	function CharNode(x,y, character)
	{
			this.moveTo = function(x,y)
			{
				moveToX = x;
				moveToY = y;
			}
			
			this.update = function()
			{
				// Animate position
				var xDelta = moveToX - this.xPos;
				var yDelta = moveToY - this.yPos;
				
				// If we're close enough, snap to position rather than multiplying increasingly minute numbers
				var animThreshold = 0.1;
				this.xPos = Math.abs(xDelta) < animThreshold ? moveToX : this.xPos + xDelta*dampen;
				this.yPos = Math.abs(yDelta) < animThreshold ? moveToY : this.yPos + yDelta*dampen;
			}
			
			this.draw = function()
			{
				// Draw the node shape
				p.stroke(0);
				p.strokeWeight(3);
				p.fill(255); // while my roundedRect doesn't enclose itself properly
				p.roundedRect(this.xPos, this.yPos, this.width, this.height, radius);
				
				// Write the text on
				p.fill(0);
				var yFontMagicOffset = 28;
				p.textFont(fontBold, textHeaderSize);
				p.text(char, this.xPos + textOffset, this.yPos + yFontMagicOffset);
			}
			
		//// Constructor
			var char = character;

			var radius = 10;
			var padding = 5;
			var textHeaderSize = 28;
			var textBodySize = 18;
						
			this.xPos = x;
			this.yPos = y;
			this.height = textHeaderSize + 2*padding;
			this.width = Math.max(fontBold.width(char)*textHeaderSize, this.height);
			var textOffset = this.width/2 - fontBold.width(char)*textHeaderSize/2;
			
			var moveToX = x;
			var moveToY = y;
	}
	
	// NODE CLASS - This is the object that represents a RDF object and its rolled-in properties such as type.
	
	function Node(x, y, objectKey)
	{
		//// Methods
			this.moveTo = function(x,y)
			{
				moveToX = x;
				moveToY = y;
			}
			
			this.initFromDownloadedObjectsData = function()
			{
				// Work out maximum width
				this.text = window.downloadedObjects[this.oKey].text;
				
				var longestString = "";
				
				for (var key in this.text)
				{ 
					var thisString = this.text[key].title + this.text[key].text;
					if (thisString.length > longestString.length) longestString = thisString;
				}
				
				var xFontMagicMultiplier = 1.5;
				var maxTextWidth = Math.max(fontRegular.width(longestString)*textBodySize*xFontMagicMultiplier, fontBold.width(this.text.type.title + this.text.type.text)*textHeaderSize*xFontMagicMultiplier);
				
				// Set Width and Height
				this.width = maxTextWidth + 2*padding;
				this.height = padding + textHeaderSize + (this.text.lineCount-1)*textBodySize + padding;
			}
			
			this.update = function()
			{
				// Animate position
				var xDelta = moveToX - this.xPos;
				var yDelta = moveToY - this.yPos;
				
				// If we're close enough, snap to position rather than multiplying increasingly minute numbers
				var animThreshold = 0.1;
				this.xPos = Math.abs(xDelta) < animThreshold ? moveToX : this.xPos + xDelta*dampen;
				this.yPos = Math.abs(yDelta) < animThreshold ? moveToY : this.yPos + yDelta*dampen;
			}
	
			this.draw = function(selected)
			{
				// Draw the node outline
				if (selected == true) 
					p.stroke(255,0,0);
				else									
					p.stroke(0);
				p.strokeWeight(3);
				p.fill(255);
				p.roundedRect(this.xPos, this.yPos, this.width, this.height, radius);
				
				// If there is the prettified text, display it.			
				if (this.text)
				{
					p.fill(0);
					
					// Move down with increasing yCurrent
					
					var yCurrent = this.yPos + padding
					
					// Draw title
					
					var yFontMagicOffset = 20;
					
					p.textFont(fontRegular, textHeaderSize);
					p.text(this.text.type.title, this.xPos + padding, yCurrent + yFontMagicOffset);
					p.textFont(fontBold, textHeaderSize);
					p.text(this.text.type.text, this.xPos + padding + fontRegular.width(this.text.type.title)*textHeaderSize, yCurrent + yFontMagicOffset);
					
					yCurrent += textHeaderSize 
										
					// Draw thin line
					
					if (this.text.lineCount > 1)
					{
						p.strokeWeight(2);
						p.line(this.xPos, yCurrent, this.xPos + this.width, yCurrent);
						yCurrent += padding;
					}
					
					// Draw body text in desired order
					
					yFontMagicOffset = 12;
					
					if ('about' in this.text)
					{
						p.textFont(fontLight, textBodySize);
						p.text(this.text.about.title, this.xPos + padding, yCurrent + yFontMagicOffset);
						p.textFont(fontRegular, textBodySize);
						p.text(this.text.about.text, this.xPos + padding + fontRegular.width(this.text.about.title)*textBodySize, yCurrent + yFontMagicOffset);
						yCurrent += textBodySize;
					}
					
					if ('name' in this.text)
					{
						p.textFont(fontLight, textBodySize);
						p.text(this.text.name.title, this.xPos + padding, yCurrent + yFontMagicOffset);
						p.textFont(fontRegular, textBodySize);
						p.text(this.text.name.text, this.xPos + padding + fontRegular.width(this.text.name.title)*textBodySize, yCurrent + yFontMagicOffset);
						yCurrent += textBodySize;
					}
					if ('comment' in this.text)
					{
						p.textFont(fontLight, textBodySize);
						p.text(this.text.comment.title, this.xPos + padding, yCurrent + yFontMagicOffset);
						p.textFont(fontRegular, textBodySize);
						p.text(this.text.comment.text, this.xPos + padding + fontRegular.width(this.text.comment.title)*textBodySize, yCurrent + yFontMagicOffset);
						yCurrent += textBodySize;
					}
				}
			}	
	
		//// Constructor
			this.oKey = objectKey;
			this.xPos = x;
			this.yPos = y;
			this.width = 0;
			this.height = 0;
			
			var moveToX = x;
			var moveToY = y;
			
			var radius = 10;
			var padding = 5;
			var textHeaderSize = 28;
			var textBodySize = 18;
			
			this.text = null;
			
			if (objectKey in window.downloadedObjects) 
			{
				this.initFromDownloadedObjectsData();
			}
	}

	
	
	//// SKETCH UTILITIES
	
	
	// COLLECTION CLASS - Its an array that keeps a selected index that should stay in bounds
	
	function SelectedIndexArray()
	{
		this.array = [];
		var index = 0;
		this.selectedIndex = function()
		{
		return index;
		}
		this.push = function(object)
		{
			this.array.push(object);
		}
		this.selectedObject = function()
		{
			if (this.array.length == 0 || index < 0 || index >= this.array.length) {console.log('selectedIndexArray not returning an object'); return null;}
			return this.array[index];
		}
		this.selectionUp = function()
		{
			index = Math.min(index + 1, Math.max(0,this.array.length - 1));
		}
		this.selectionDown = function()
		{
			index = Math.max(index - 1, 0)
		}
		this.reset = function()
		{
			this.array = [];
			index = 0;
		}
	} 
	
	// GRAPHIC ROUTINE - Rounded Rectangle
	
	// processing.js is missing quadratic bezier, needed to draw corners with correct curvature
	// FIXME: Rather than having to declare it, keep prevX & Y in state somehow?
	p.quadraticBezierVertex = function(cpx, cpy, x, y, prevX, prevY) 
	{
	  var cp1x = prevX + 2.0/3.0*(cpx - prevX);
	  var cp1y = prevY + 2.0/3.0*(cpy - prevY);
	  var cp2x = cp1x + (x - prevX)/3.0;
	  var cp2y = cp1y + (y - prevY)/3.0;
	
	  // and now call cubic Bezier curve to function
	  p.bezierVertex(cp1x, cp1y, cp2x, cp2y, x, y);
	};
	
	p.roundedRect = function(x, y, w, h, r) 
	{
	  p.beginShape();
	  p.vertex(x+r, y);
	  p.vertex(x+w-r, y);
		p.quadraticBezierVertex(x+w, y, x+w, y+r, x+w-r, y);
	  p.vertex(x+w, y+h-r);
	  p.quadraticBezierVertex(x+w, y+h, x+w-r, y+h, x+w, y+h-r);
	  p.vertex(x+r, y+h);
	  p.quadraticBezierVertex(x, y+h, x, y+h-r, x+r, y+h);
	  p.vertex(x, y+r);
	  p.quadraticBezierVertex(x, y, x+r, y, x, y+r);
	  p.endShape();
	};
}